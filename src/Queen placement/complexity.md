# Оценка сложности

Предисловие: анализ сложности каждого решения задачи о расстановке ферзей является примерным и использует нотацию ***Big O***, то есть нотацию, применяемую для оценки худшего случая работы алгоритма.

## Переборное решение (brute_force_solution)

Сложность: O($n! * n^2$) <br>
Обоснование: Проходим по всем перестановкам столбцов (по формуле из комбинаторики их количество $= n!$), а при рассмотрении каждой перестановки запускаются два цикла "for" для проверки отсутствия конфликтующих по диагоналям ферзей.

## Рекурсивное решение (recursive_solution)

Сложность: O($n!$)<br>
Обоснование: В худшем случае так же, как и в первом решении, перебираются все перестановки, однако здесь отсутсвуют два цикла ***for***, а проверка корректности расстановки проводится с помощью множеств. Сложность связанных с последним операций не учитывается, так как за счёт хорошо реализованных хеш-функций для целых чисел и практически полного отсутствия вследствие этого коллизий поиск в ***set*** в Python проходит за O(1).<br>
Примечание: Хоть сложность и близка к сложности первого решения ($n!$ растёт быстрее, чем $n^2$), но на практике работает быстрее, благодаря раннему отсечению некорректных веток.

## Самое быстрое решение - через битовые маски (bitmask_solution)

Сложность: O($n!$)<br>
Обоснование: В худшем случае снова перебираются все перестановки, но по сравнению с рекурсивным решением проверка корректности всегда происходит за O(1) - рассматривются битовые маски.<br>
Примечание: Работает быстрее за счёт отсутствия операций с множествами (хеширование, поиск в хеш-таблицах), что в совокупности с битовыми операциями, которые выполняются за один такт, составляет процессорную оптимизацию. Также положительно влияет отсутствие динамического выделения памяти под множества.
